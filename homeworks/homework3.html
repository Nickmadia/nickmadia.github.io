<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 3: Central Tendency: A Comprehensive Analysis</title>
    <link rel="stylesheet" href="../style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
    <style>
        .charts-container {
            display: flex;
            margin: 0;
        }
        .chart-wrapper {
            flex: 0;
        }
        .flipped-chart {
            transform: rotate(90deg); /* Flips the chart by 90 degrees clockwise */
        }  pre {
            background-color: #f4f4f409; /* Light gray background */
            padding: 10px; /* Padding for the code */
            border-radius: 5px; /* Rounded corners */
            overflow-x: auto; /* Scrollable if too long */
        }
    </style>
</head>
<body>
    <header>
            <h1>Central Tendency: A Comprehensive Analysis</h1>
    </header>

    <main>
        <section>

            <div class="section">
                <h2>1. The Median Minimization Property: A Rigorous Analysis</h2>
                
                <div class="theorem">
                    <strong class="important">Theorem 1.1:</strong> For any set of real numbers {x₁, ..., xₙ}, the median minimizes the sum of absolute deviations:
                    <p class="math">
                        m = argmin<sub>c</sub> Σ|xᵢ - c|
                    </p>
                </div>
        
                <div class="proof">
                    <strong class="important">Visual Proof:</strong>
                    <p>Consider why median minimizes Σ|xᵢ - c|:</p>
                    <ul>
                        <li>For any value c:
                            <ul>
                                <li>Points to the left of c contribute: Σ(c - xᵢ)</li>
                                <li>Points to the right of c contribute: Σ(xᵢ - c)</li>
                            </ul>
                        </li>
                        <li>At the median:
                            <ul>
                                <li>Number of points on left = Number of points on right</li>
                                <li>Moving c in either direction increases total absolute deviation</li>
                                <li>Therefore, median is the minimizer</li>
                            </ul>
                        </li>
                    </ul>
                </div>
        
                <div class="theorem">
                    <strong class="important">Theorem 1.2 (Generalization):</strong> 
                    <p>For any strictly convex function g(t), the minimizer of:</p>
                    <p class="math">Σ g(|xᵢ - c|)</p>
                    <p>defines a valid location statistic.</p>
                </div>
            </div>
        
            <div class="section">
                <h2>2. Taxonomy of Location Statistics</h2>
        
                <div class="definition">
                    <strong class="important">A. Minimization-Based Definitions</strong>
                    <ol>
                        <li class="math">L₁-center (Median): argmin_c Σ|xᵢ - c|</li>
                        <li class="math">L₂-center (Mean): argmin_c Σ(xᵢ - c)²</li>
                        <li class="math">L₄-center: argmin_c Σ(xᵢ - c)⁴</li>
                        <li class="math">L∞-center (Minimax): argmin_c max|xᵢ - c|</li>
                        <li class="math">Huber center: argmin_c Σρ(xᵢ - c)</li>
                        <li class="math">Tukey biweight: argmin_c Σ(1 - (1 - ((x-c)/k)²)³)</li>
                        <li class="math">Andrew's sine: argmin_c Σ(1 - cos((x-c)/k))</li>
                    </ol>
                </div>
        
                <div class="definition">
                    <strong class="important">B. Probabilistic Definitions</strong>
                    <ol>
                        <li class="math">Mean: E[X]</li>
                        <li class="math">Median: F⁻¹(1/2)</li>
                        <li class="math">Mode: argmax f(x)</li>
                        <li class="math">Trimmed mean: E[X|X ∈ (q₁, q₂)]</li>
                        <li class="math">Winsorized mean: Mean after replacing extremes</li>
                        <li class="math">Quantile-based: (Q₁ + Q₂ + Q₃)/3</li>
                        <li class="math">Hodges-Lehmann: median{(xᵢ + xⱼ)/2}</li>
                        <li class="math">Weighted median: Σwᵢxᵢ</li>
                    </ol>
                </div>
        
                <div class="definition">
                    <strong class="important">C. Geometric Definitions</strong>
                    <ol>
                        <li>Spatial median: Point minimizing sum of distances</li>
                        <li>Centroid: Center of mass</li>
                        <li>Circumcenter: Center of circumscribed circle</li>
                        <li>Incenter: Center of inscribed circle</li>
                        <li>Orthocenter: Intersection of altitudes</li>
                        <li>Barycenter: Weighted center of mass</li>
                        <li>Fermat point: Point minimizing sum of distances to vertices</li>
                    </ol>
                </div>
            </div>
        
            <div class="section">
                <h2>3. Generalized Framework</h2>
                
                <div class="theorem">
                    <strong class="important">General Form:</strong>
                    <p class="math">Location Statistic = argmin_c Σg(d(xᵢ, c))</p>
                    <p>where:</p>
                    <ul>
                        <li>d(·,·) is any distance metric</li>
                        <li>g(·) is any convex function</li>
                    </ul>
                </div>
        
                <div class="definition">
                    <strong class="important">Common Distance Metrics (d):</strong>
                    <ul>
                        <li class="math">Euclidean: d(x,y) = |x-y|</li>
                        <li class="math">Manhattan: d(x,y) = Σ|xᵢ-yᵢ|</li>
                        <li class="math">Mahalanobis: d(x,y) = √((x-y)ᵀS⁻¹(x-y))</li>
                        <li class="math">p-norm: d(x,y) = (Σ|xᵢ-yᵢ|ᵖ)^(1/p)</li>
                    </ul>
                </div>
        
                <div class="definition">
                    <strong class="important">Common Loss Functions (g):</strong>
                    <ul>
                        <li class="math">Identity: g(t) = t</li>
                        <li class="math">Square: g(t) = t²</li>
                        <li class="math">Huber: g(t) = t²/2 if |t|≤k else k|t|-k²/2</li>
                        <li class="math">Log-cosh: g(t) = log(cosh(t))</li>
                        <li class="math">Pseudo-Huber: g(t) = δ²(√(1+(t/δ)²)-1)</li>
                    </ul>
                </div>
        
                <div class="theorem">
                    <strong class="important">Theorem 3.1: Infinite Extensions</strong>
                    <p>The framework of location statistics can be extended infinitely through:</p>
                    
                    <ol>
                        <li><span class="important">Function Composition:</span> Any composition of convex functions with distance metrics creates a new valid location statistic:
                            <p class="math">L(c) = Σ(g₁ ∘ g₂ ∘ ... ∘ gₙ)(d(xᵢ, c))</p>
                        </li>
                        
                        <li><span class="important">Weighted Combinations:</span> Any convex combination of existing location statistics yields a new valid statistic:
                            <p class="math">L(c) = α₁L₁(c) + α₂L₂(c) + ... + αₙLₙ(c)</p>
                            <p>where Σαᵢ = 1 and αᵢ ≥ 0</p>
                        </li>
                        
                        <li><span class="important">Parameter Families:</span> Each loss function can be parameterized:
                            <p class="math">g(t; θ) = θ₁g₁(t) + θ₂g₂(t) + ...</p>
                            <p>Creating continuous families of location statistics</p>
                        </li>
                    </ol>
                </div>
        
                <div class="proof">
                    <strong class="important">Implications of Infinite Extensibility:</strong>
                    <p>This framework leads to infinite possibilities through:</p>
                    <ul>
                        <li><span class="important">Metric Spaces:</span> Any metric space (M,d) induces a family of location statistics</li>
                        <li><span class="important">Function Spaces:</span> Different function spaces (L<sup>p</sup>, Sobolev, etc.) generate different families</li>
                        <li><span class="important">Kernel Methods:</span> Any positive definite kernel k(x,y) defines a new distance metric:
                            <p class="math">d(x,y) = √(k(x,x) + k(y,y) - 2k(x,y))</p>
                        </li>
                        <li><span class="important">Adaptive Weights:</span> Data-dependent weighting schemes:
                            <p class="math">w(x,data) = f(x, {xᵢ})</p>
                        </li>
                    </ul>
                </div>
        
                <div class="note">
                    <strong class="important">Construction Principles:</strong>
                    <p>New location statistics can be systematically generated by:</p>
                    <ol>
                        <li>Choosing a base distance metric (d)</li>
                        <li>Selecting or constructing a loss function (g)</li>
                        <li>Adding weights (w)</li>
                        <li>Applying transformations (T)</li>
                        <li>Combining existing statistics</li>
                    </ol>
                    <p>Each choice in this process can be parameterized, leading to continuous families of statistics. Moreover, each family can be further combined or transformed, creating an infinite recursive structure of possible definitions.</p>
                </div>
            </div>
        
           
         <h2>Practice</h2>
        <form id="inputForm">
            <label for="servers"># Times (n):</label>
            <input type="number" id="servers" name="servers" min="1" value="100" required><br>

            <label for="attackers"># Times (n):</label>
            <input type="number" id="attackers" name="attackers" min="1" value="50" required><br>

            <label for="probability">λ:</label>
            <input type="number" id="probability" name="probability" min="0" value="50" required><br>

            <label for="time">Istant of time T where to check the mid distribution:</label>
            <input type="number" id="time" name="time T" min="0" value="40" required><br>

            <button type="button" onclick="runSimulation()">Run Simulation</button>
        </form>

        <!-- Charts for visualizing results -->
        <div class="charts-container" >
            <div class="chart-wrapper">
                <canvas id="penetrationLineChart" height="550"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="penetrationDistributionChart" width="150" height="550"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="line2" width="450" height="550"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="distributionChart2" height="550"></canvas>
            </div>
        </div>
        
        <!-- Panel for statistical results -->
        <div class="statistics-container">
            <div id="statisticsPanelt" class="centered-div">
                <h3>Statistics at time T</h3>
                <p><strong>Mean:</strong> <span id="meant">N/A</span></p>
                <p><strong>Variance:</strong> <span id="stdDevt">N/A</span></p>
            </div>
            <div id="statisticsPanel" class="centered-div">
                <h3>Statistics </h3>
                <p><strong>Mean:</strong> <span id="mean">N/A</span></p>
                <p><strong>Variance:</strong> <span id="stdDev">N/A</span></p>
            </div>
        </div>
         
        </section>

    </main>

    <footer>
        <p>&copy; 2024 My Statistics Blog</p>
    </footer>
    <script>
        let charts= {};
        function runSimulation() {

            const n = parseInt(document.getElementById('servers').value);
            const m = parseInt(document.getElementById('attackers').value);
            const p = parseFloat(document.getElementById('probability').value);
            const t = parseInt(document.getElementById('time').value);
 
            //helper function to determine successfullnes
            const attackOutcome = () => Math.random() < p/n ? 1 : 0;
           
            const generateTrajectory = () => {
                return Array.from({ length: n }, () => 0)  // Creates an array of `n` zeros
                    .reduce((trajectory) => {
                        const lastValue = trajectory[trajectory.length - 1] || 0;
                    return [...trajectory, lastValue + attackOutcome()];
                    }, []);
            };
            // Run simulation for each attacker
            const allTrajectories = Array.from({ length: m }, () => generateTrajectory());

            // Compute the final distribution of the attackers who reached each penetration level
            const getDistribution = arr => arr 
                .map(trajectory => trajectory[trajectory.length - 1]) // Get final position for each attacker
                .reduce((acc, position) => {
                    acc[position] = (acc[position] || 0) + 1; // Count occurrences of each final position
                return acc;
             }, {});
            
            const maxAbsValue = arr => Math.max(...arr.flat().map(Math.abs)); // get max abs value in order to display the correct y axis's values
            const getSlice = (arr,s,e) => arr.map((x) => x.slice(s,e));
            let chartRange = maxAbsValue(allTrajectories); 
            // Update both charts
            const temp = getSlice(allTrajectories,0,t);
            
            updateLineChart(temp, t-1,chartRange,'penetrationLineChart');
            updateDistributionChart(getDistribution(temp), n,chartRange, 'penetrationDistributionChart');
            updateLineChart(getSlice(allTrajectories,t,n), n-t,chartRange,'line2');
            updateDistributionChart(getDistribution(allTrajectories), n,chartRange, 'distributionChart2');
            
            //little helper to get the array representing the distribution
            const getDistr = x => x.map( y => y[y.length -1 ]);
            const finalDistribution = getDistr(allTrajectories);

            //distr at time t
            const rest = welfordRecursive(getDistr(temp));
            //distr at final 
            const res = welfordRecursive(finalDistribution);
            

            document.getElementById('mean').textContent = res.mean.toFixed(3);
            document.getElementById('meant').textContent = rest.mean.toFixed(3);
            document.getElementById('stdDev').textContent = res.variance.toFixed(3);
            document.getElementById('stdDevt').textContent = rest.variance.toFixed(3);

        }
 
        function updateLineChart(lineData, n, chartRange, chart) {
            const ctx = document.getElementById(chart).getContext('2d');
            const labels = Array.from({ length: n + 1 }, (_, i) => `${i}`);
            const datasets = lineData.map((data, index) => ({
                label: `Attacker ${index + 1}`,
                data: data.map((value, i) => ({ x: i, y: value })), // Properly map x and y
                fill: false,
                borderColor: `rgba(${Math.floor(Math.random() * 255)}, 0, 255, 0.7)`,
                borderWidth: 1,
                stepped: true, // This makes the line flat until a jump
                pointRadius:0,
            }));
 
            if (charts[chart]){
                charts[chart].destroy();
            } 
            charts[chart] = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    scales: {
                       
                     y: { 
                     beginAtZero: true,  max: chartRange,display:false // Always display 0 even if no data reaches it
                 } 
                    } ,
             plugins: {
                 legend: {
                     display: false // Disable the legend
                 }
             
                }
            }});
        }
 
        function updateDistributionChart(results, n,chartRange,chart) {
            const ctx = document.getElementById(chart).getContext('2d');
            const labels = Array.from({ length: chartRange}, (_, i) => (i).toString());
            console.log(labels);
            if (charts[chart]){
                charts[chart].destroy();
            } 
            charts[chart] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Attackers',
                        data: results,
                        backgroundColor:Array.from({ length: n }, () => 
                        `rgba(${Math.floor(Math.random() * 255)}, 0, 255, 0.7)`), 
                    }]
                },
                options: {
                    indexAxis: 'y', // Align bars with attackers
                    scales: {
                        x: { beginAtZero: true },
                        y: { reverse: true, display:false, beginAtZero:true }
                    },   
             plugins: {
                 legend: {
                     display: false // Disable the legend
                 }
             },
                }
            });
        }

        function welford(arr) {
         let mean = 0;
         let M2 = 0; 
         let N = 0; 
 
         for (let x of arr) {
             N += 1;
             const delta = x - mean;
             mean += delta / N;
             M2 += delta * (x - mean);
         }
 
         const variance = N > 1 ? M2 / (N -1  ) : 0; // Sample variance; use N for population variance
         const standardDeviation = Math.sqrt(variance);
 
         return {
             mean: mean,
             variance: variance,
             standardDeviation: standardDeviation,
         };
 }      
        function welfordRecursive  ([x, ...xs], n = 0, mean = x, m2 = 0) { 
            return x === undefined
                ? { mean, variance: n > 1 ? m2 / (n - 1) : 0 }
                : welfordRecursive(xs, n + 1, mean + (x - mean) / (n + 1), m2 + (x - mean) * (x - mean + (x - mean) / (n + 1)));
        }   

 
        function calculateMode(arr) {
            const frequencyMap = {};
            arr.forEach(value => {
                if (frequencyMap[value]) {
                    frequencyMap[value]++;
                } else {
                    frequencyMap[value] = 1;
                }
            });
 
            let mode = null;
            let maxCount = 0;
            for (const [key, value] of Object.entries(frequencyMap)) {
                if (value > maxCount) {
                    maxCount = value;
                    mode = key;
                }
            }
            return mode;
        }
    </script> 
</body>
</html>