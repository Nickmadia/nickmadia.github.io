<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Magic of the Central Limit Theorem </title>
    <link rel="stylesheet" href="../style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
    <style>
        .charts-container {
            display: flex;
            margin: 0;
        }
        .chart-wrapper {
            flex: 0;
        }
        .flipped-chart {
            transform: rotate(90deg); /* Flips the chart by 90 degrees clockwise */
        }  pre {
            background-color: #f4f4f409; /* Light gray background */
            padding: 10px; /* Padding for the code */
            border-radius: 5px; /* Rounded corners */
            overflow-x: auto; /* Scrollable if too long */
        }.button-group {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover {
            background-color: #2563eb;
        }
        .error {
            color: #dc2626;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fee2e2;
            border-radius: 4px;
            display: none;
        }
        .sum-display {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <header>
        <h1>Homework 6</h1>
    </header>

    <main>
        <section>
          <h1>The Central Limit Theorem: A Statistical Miracle</h1>

          <div class="theorem">
              <h3>Central Limit Theorem Statement</h3>
              <p>Let \(X_1, X_2, \ldots, X_n\) be independent and identically distributed random variables with:</p>
              <ul>
                  <li>\(\mathbb{E}[X_i] = \mu\)</li>
                  <li>\(Var(X_i) = \sigma^2\)</li>
              </ul>
      
              <p>Then as \(n \to \infty\), the distribution of the sample mean \(\bar{X}\) converges to a normal distribution:</p>
      
              <p>\[\bar{X} \sim \mathcal{N}\left(\mu, \frac{\sigma^2}{n}\right)\]</p>
          </div>
      
          <div class="key-insight">
              <p>The Central Limit Theorem reveals a profound statistical truth: regardless of the original distribution's shape, sample means will converge to a normal distribution as sample size increases.</p>
          </div>
      
          <h2>Mathematical Foundations</h2>
      
          <div class="theorem">
              <h3>Mean Calculation</h3>
              <p>Population mean calculated as:</p>
              <p>\[\mu = \mathbb{E}[X] = \sum_{i} x_i \cdot P(X = x_i)\]</p>
          </div>
      
          <div class="theorem">
              <h3>Variance Calculation</h3>
              <p>Population variance defined as:</p>
              <p>\[\sigma^2 = \mathbb{E}[(X - \mu)^2] = \sum_{i} (x_i - \mu)^2 \cdot P(X = x_i)\]</p>
          </div>
      
          <h2>Practical Implications</h2>
      
          <div class="key-insight">
              <p>The theorem's significance lies in its universality: it applies across diverse fields including:</p>
              <ul>
                  <li>Statistical inference</li>
                  <li>Hypothesis testing</li>
                  <li>Confidence interval estimation</li>
                  <li>Financial risk analysis</li>
              </ul>
          </div>
      
          <h2>Convergence Principle</h2>
      
          <div class="theorem">
              <h3>Probabilistic Convergence</h3>
              <p>As sample size increases, the standardized sample mean converges to the standard normal distribution:</p>
              <p>\[\lim_{n \to \infty} P\left(\frac{\bar{X} - \mu}{\sigma/\sqrt{n}} \leq z\right) = \Phi(z)\]</p>
              <p>Where \(\Phi(z)\) is the cumulative distribution function of the standard normal distribution.</p>
          </div>
      
          <h2>Practical Considerations</h2>
      
          <p>The rate of convergence depends on the original distribution's characteristics:</p>
          <ul>
              <li>Symmetric distributions: Faster convergence</li>
              <li>Highly skewed distributions: Slower convergence</li>
              <li>Generally, larger sample sizes improve approximation</li>
          </ul>
      
          <h2>Conclusion</h2>
      
          <p>The Central Limit Theorem bridges randomness and predictability, demonstrating how complex statistical phenomena can be understood through elegant mathematical principles.</p>
      

          <h1>Practice</h1>
          <form id="inputForm">
            <div class="input-group">
  
              <label for="samples"># samples (n): </label>
              <input type="number" id="maxSamples" name="samples" min="1" value="3000" required><br>
              <label for="samplesSize">sample size (m): </label>
              <input type="number" id="sampleSize" name="samples" min="1" value="500" required><br>
            </div>
            <div class="inputs-container">
              <div class="input-group">
                <label for="prob1">Probability 1:</label>
                <input type="number" id="prob1" step="0.0001" min="0" max="1" value="0.1000">
            </div>
            <div class="input-group">
                <label for="prob2">Probability 2:</label>
                <input type="number" id="prob2" step="0.0001" min="0" max="1" value="0.2000">
            </div>
            <div class="input-group">
                <label for="prob3">Probability 3:</label>
                <input type="number" id="prob3" step="0.0001" min="0" max="1" value="0.3000">
            </div>
            <div class="input-group">
                <label for="prob4">Probability 4:</label>
                <input type="number" id="prob4" step="0.0001" min="0" max="1" value="0.1500">
            </div>
            <div class="input-group">
                <label for="prob5">Probability 5:</label>
                <input type="number" id="prob5" step="0.0001" min="0" max="1" value="0.2500">
            </div>
            <div class="button-group">
                <button type="button" onclick="randomizeProbabilities()">Randomize</button>
            </div>
           </div> 
            <div class="sum-display">Current Sum: <span id="sumDisplay">1.0000</span>
            </div>
            <div id="errorMessage" class="error">
                Probabilities must sum to 1
            </div>
            
            
  
              <button type="button" onclick="runSimulation()">Run Simulation</button>
          </form>
  
          <!-- Charts for visualizing results -->
              <canvas id="distributionChart" height="300" width="800"> </canvas>
         
          
          <!-- Panel for statistical results -->
          <div class="statistics-container">
              <div id="statisticsPanelt" class="centered-div">
                  <h3>Theoretical Stats</h3>
                  <p><strong>Mean:</strong> <span id="meant">N/A</span></p>
                  <p><strong>Variance:</strong> <span id="stdDevt">N/A</span></p>
              </div>
              <div id="statisticsPanel" class="centered-div">
                  <h3>Empirical Stats</h3>
                  <p><strong>Mean of Means:</strong> <span id="mean">N/A</span></p>
                  <p><strong>Variance of Means:</strong> <span id="stdDev">N/A</span></p>
              </div>
          </div>
        </section>
    </main>
    
       <script>        
        let charts= {};
        const values = [1, 2, 3, 4,5]; // Numerical values for mean/variance calculation
        const probabilities = [];
        let theoreticalMean ;
        let theoreticalVariance;
        function getInputValues() {
          probabilities.length = 0;
            for (let i = 1; i <= 5; i++) {
                probabilities.push(parseFloat(document.getElementById(`prob${i}`).value) || 0);
            }
          } 
          function updateSum() {
            
            let sum = probabilities.reduce((a, b) => a + b, 0);
            document.getElementById('sumDisplay').textContent = sum.toFixed(4);
            
            const errorElement = document.getElementById('errorMessage');
            if (Math.abs(sum - 1) > 0.0001) {
                errorElement.style.display = 'block';
                return false;
            } else {
                errorElement.style.display = 'none';
                return true;
            }
            
        }
        function getTheoreticalStats(){

        theoreticalMean = values.reduce((sum, val, i) => sum + val * probabilities[i], 0);
        theoreticalVariance = values.reduce((sum, val, i) => sum + probabilities[i] * Math.pow(val - theoreticalMean, 2), 0);
        }
        function randomizeProbabilities(){
          const randomNumbers = [];
            let sum = 0;
            
            // Generate random numbers
            for (let i = 0; i < 5; i++) {
                const rand = Math.random();
                randomNumbers.push(rand);
                sum += rand;
            }
            
            // Normalize to sum to 1
            for (let i = 0; i < 5; i++) {
                const normalizedValue = (randomNumbers[i] / sum).toFixed(4);
                document.getElementById(`prob${i + 1}`).value = normalizedValue;
            }
        }
       function runSimulation() {
            //const options = acquireOptions(); 

                        // Values and probabilities for the discrete distribution

            // Theoretical mean and variance

            // Generate realizations and track frequencies, mean, variance
            getInputValues();
            if (!updateSum()){
              return
            }
            getTheoreticalStats();
            const realizations = [];
            const sampleMeans = [];
            const sampleMeanStats = new Welford();
            
            const maxSamples = parseInt(document.getElementById('maxSamples').value);
            const sampleSize = parseInt(document.getElementById('sampleSize').value);
            for (let i = 1; i <= maxSamples; i++) {
              const statsSample = new Welford();
              for ( let j = 0; j < sampleSize; j++) {
                const realization = generateRealization(values, probabilities);
                realizations.push(realization);


                // Update mean and variance using Welford's algorithm
                statsSample.add(realization);
              }
              sampleMeans.push(statsSample.mean);
                
            }
            sampleMeans.forEach(mean => sampleMeanStats.add(mean));
            // get stats from sampleMeanStats.mean
            udpateStats(theoreticalMean,theoreticalVariance,sampleMeanStats.mean, sampleMeanStats.variance());
            plotDistribution(sampleMeans,maxSamples);
    }
  function udpateStats(tMean,tVariance,eMean,eVariance) {
    document.getElementById('mean').textContent = eMean.toFixed(3);
    document.getElementById('meant').textContent = tMean.toFixed(3);
    document.getElementById('stdDev').textContent = eVariance.toFixed(3);
    document.getElementById('stdDevt').textContent = tVariance.toFixed(3);
  }
  // Function to generate random realization based on a given probability distribution
  function generateRealization(values, probabilities) {
    const cumulativeProbabilities = [];
    probabilities.reduce((acc, prob, i) => {
      cumulativeProbabilities[i] = acc + prob;
      return cumulativeProbabilities[i];
    }, 0);

    const rand = Math.random();
    return values[cumulativeProbabilities.findIndex(cumProb => rand < cumProb)];
  }

  // Welford's algorithm for mean and variance computation
  class Welford {
    constructor() {
      this.n = 0;
      this.mean = 0;
      this.m2 = 0; // Sum of squares of differences from the current mean
    }

    add(value) {
      this.n++;
      const delta = value - this.mean;
      this.mean += delta / this.n;
      this.m2 += delta * (value - this.mean);
    }

    variance() {
      return this.n > 1 ? this.m2 / (this.n - 1) : 0;
    }
  }

  

  function plotDistribution(means, samples) {
            const bins = 30;
            const min = Math.min(...means);
            const max = Math.max(...means);
            const histogram = new Array(bins).fill(0);
            const binEdges = Array.from({length: bins + 1}, (_, i) => 
            min + (max - min) * i / bins
          );
          
          means.forEach(mean => {
            const binIndex = Math.floor((mean - min) / (max - min) * bins);
            histogram[Math.min(binIndex, bins - 1)]++;
          });
          
          // Destroy previous chart if it exists
          if (charts['distributionChart']){
                      charts['distributionChart'].destroy();
                  } 

            const ctx = document.getElementById('distributionChart').getContext('2d');
            charts['distributionChart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binEdges.slice(0, -1).map(edge => edge.toFixed(2)),
                    datasets: [{
                        label: 'Sample Means Distribution',
                        data: histogram,
                        backgroundColor: 'rgba(100, 0, 255, 0.6)',
                        borderColor: 'rgba(100, 0, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Sample Mean'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Frequency'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
  
        function acquireOptions(){
            return  {
            servers : parseInt(document.getElementById('servers').value),
            attackers: parseInt(document.getElementById('attackers').value),
            p : parseFloat(document.getElementById('probability').value),
            t : parseInt(document.getElementById('time').value),
            type : parseInt(document.getElementById('typeSelector').value)
            }
        }
        function welford(arr) {
         let mean = 0;
         let M2 = 0; 
         let N = 0; 
 
         for (let x of arr) {
             N += 1;
             const delta = x - mean;
             mean += delta / N;
             M2 += delta * (x - mean);
         }
 
         const variance = N > 1 ? M2 / (N -1  ) : 0; // Sample variance; use N for population variance
         const standardDeviation = Math.sqrt(variance);
 
         return {
             mean: mean,
             variance: variance,
             standardDeviation: standardDeviation,
         };
 }      
        function welfordRecursive  ([x, ...xs], n = 0, mean = x, m2 = 0) { 
            return x === undefined
                ? { mean, variance: n > 1 ? m2 / (n - 1) : 0 }
                : welfordRecursive(xs, n + 1, mean + (x - mean) / (n + 1), m2 + (x - mean) * (x - mean + (x - mean) / (n + 1)));
        }   

 
        function calculateMode(arr) {
            const frequencyMap = {};
            arr.forEach(value => {
                if (frequencyMap[value]) {
                    frequencyMap[value]++;
                } else {
                    frequencyMap[value] = 1;
                }
            });
 
            let mode = null;
            let maxCount = 0;
            for (const [key, value] of Object.entries(frequencyMap)) {
                if (value > maxCount) {
                    maxCount = value;
                    mode = key;
                }
            }
            return mode;
        }
       </script>
</body>
</html>